name: Dev Release

# Called by publish.yml (the npm Trusted Publisher entry point)
on:
  workflow_call:
    inputs:
      npm_tag:
        description: "NPM tag for the release"
        required: false
        default: "dev"
        type: string

env:
  CI: true

jobs:
  release:
    name: Dev Release
    if: github.repository == 'langchain-ai/langchainjs'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    steps:
      - name: â¬‡ï¸ Checkout repo
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          fetch-depth: 0

      - name: ðŸ“¦ Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0

      - name: âŽ” Setup node
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version-file: ".nvmrc"
          cache: "pnpm"

      - name: ðŸ“¥ Install deps
        run: pnpm install --frozen-lockfile

      - name: ðŸ” Check for changesets
        id: changesets
        run: |
          # Check if there are any changeset files (excluding README.md)
          CHANGESET_COUNT=$(find .changeset -name "*.md" ! -name "README.md" | wc -l | tr -d ' ')
          echo "count=$CHANGESET_COUNT" >> $GITHUB_OUTPUT
          if [ "$CHANGESET_COUNT" -eq 0 ]; then
            echo "::error::No changesets found. Please add a changeset before running a dev release."
            echo "::error::Run 'pnpm changeset' to create a changeset for your changes."
            exit 1
          fi
          echo "Found $CHANGESET_COUNT changeset(s)"

      - name: ðŸ§¹ Prepare for snapshot release
        run: |
          # Disable changelog generation for snapshot releases
          # Enable useCalculatedVersion to preserve current version (e.g., 1.2.0-dev-xxx instead of 0.0.0-dev-xxx)
          pnpm dlx json -I -f .changeset/config.json -e "this.changelog = false; this.snapshot = { useCalculatedVersion: true, prereleaseTemplate: '{tag}-{timestamp}' }"

      - name: ðŸ“¦ Version packages (snapshot)
        id: version
        run: |
          # Version all packages with changesets using snapshot mode
          # This will also update internal dependencies automatically
          OUTPUT=$(pnpm changeset version --snapshot ${{ inputs.npm_tag }} 2>&1) || true
          echo "$OUTPUT"
          if echo "$OUTPUT" | grep -q "No unreleased changesets found"; then
            echo "success=0" >> $GITHUB_OUTPUT
          else
            echo "success=1" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ“¥ Reinstall deps after versioning
        if: steps.version.outputs.success == '1'
        run: |
          # Re-run install to update workspace links after changeset version modified package.json files
          # This ensures pnpm pack can resolve workspace:* protocols correctly during build validation
          pnpm install --no-frozen-lockfile

      - name: ðŸ”¨ Build packages
        if: steps.version.outputs.success == '1'
        run: |
          # Build all packages (turbo will handle dependency order)
          pnpm run build

      - name: ðŸ” Setup npm auth
        if: steps.version.outputs.success == '1'
        run: |
          echo "registry=https://registry.npmjs.org" >> ~/.npmrc
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" >> ~/.npmrc

      - name: ðŸš€ Publish to npm
        if: steps.version.outputs.success == '1'
        run: |
          # Only publish packages with snapshot versions (ignore pending regular releases)
          echo "ðŸ” Searching for packages to publish..."
          echo "ðŸ“‹ Looking for versions containing: -${{ inputs.npm_tag }}-"

          PUBLISHED_COUNT=0
          SKIPPED_COUNT=0

          for pkg_json in $(find libs -name "package.json" -not -path "*/node_modules/*"); do
            version=$(jq -r '.version' "$pkg_json")
            name=$(jq -r '.name' "$pkg_json")
            private=$(jq -r '.private // false' "$pkg_json")

            if [[ "$private" == "true" ]]; then
              echo "â­ï¸  Skipping $name (private package)"
              continue
            fi

            if [[ "$version" == *"-${{ inputs.npm_tag }}-"* ]]; then
              echo "ðŸ“¦ Publishing $name@$version"
              dir=$(dirname "$pkg_json")
              (cd "$dir" && pnpm publish --tag ${{ inputs.npm_tag }} --no-git-checks --access public)
              PUBLISHED_COUNT=$((PUBLISHED_COUNT + 1))
            else
              echo "â­ï¸  Skipping $name@$version (no snapshot suffix)"
              SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
            fi
          done

          echo ""
          echo "âœ… Published: $PUBLISHED_COUNT packages"
          echo "â­ï¸  Skipped: $SKIPPED_COUNT packages"

          if [[ "$PUBLISHED_COUNT" -eq 0 ]]; then
            echo "::warning::No packages with snapshot versions were found to publish"
          fi
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_CONFIG_PROVENANCE: true

      - name: ðŸ“‹ Get published packages
        if: steps.version.outputs.success == '1' && github.ref != 'refs/heads/main'
        id: published
        uses: actions/github-script@v8.0.0
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Find all package.json files in libs directory using built-in fs
            const libsDir = path.join(process.cwd(), 'libs');
            const allFiles = fs.readdirSync(libsDir, { recursive: true });
            const files = allFiles
              .filter(f => f.endsWith('package.json') && !f.includes('node_modules'))
              .map(f => path.join(libsDir, f));

            const tag = '${{ inputs.npm_tag }}';
            const packages = [];

            for (const file of files) {
              try {
                const content = fs.readFileSync(file, 'utf8');
                const pkg = JSON.parse(content);

                // Check if this package has a snapshot version
                if (pkg.version && pkg.version.includes(`-${tag}`)) {
                  packages.push({
                    name: pkg.name,
                    version: pkg.version
                  });
                }
              } catch (e) {
                // Skip files that can't be parsed
              }
            }

            if (packages.length === 0) {
              console.log('No packages with snapshot versions found');
              core.setOutput('packages', '[]');
              core.setOutput('count', '0');
              return;
            }

            // Sort packages alphabetically
            packages.sort((a, b) => a.name.localeCompare(b.name));

            console.log(`Found ${packages.length} published package(s):`);
            packages.forEach(p => console.log(`  - ${p.name}@${p.version}`));

            core.setOutput('packages', JSON.stringify(packages));
            core.setOutput('count', packages.length.toString());

            // Write to step summary
            const summary = core.summary
              .addHeading('ðŸ“¦ Published Packages', 3)
              .addTable([
                [{data: 'Package', header: true}, {data: 'Version', header: true}],
                ...packages.map(p => [p.name, `\`${p.version}\``])
              ])
              .addHeading('Install', 4)
              .addCodeBlock(
                packages.map(p => `npm i ${p.name}@${p.version} --save-exact`).join('\n'),
                'sh'
              );

            await summary.write();

      - name: ðŸ’¬ Comment on PR
        if: steps.version.outputs.success == '1' && steps.published.outputs.count != '0' && github.ref != 'refs/heads/main'
        uses: actions/github-script@v8.0.0
        with:
          script: |
            // Get the current branch name
            const branch = context.ref.replace('refs/heads/', '');

            // Find open PRs where this branch is the head
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${branch}`
            });

            if (prs.length === 0) {
              console.log(`No open PRs found for branch: ${branch}`);
              return;
            }

            const packages = JSON.parse('${{ steps.published.outputs.packages }}');
            const run_url = `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`;

            // Build the package table
            const tableRows = packages.map(p => `| ${p.name} | \`${p.version}\` |`).join('\n');

            // Build install commands
            const packageVersions = packages.map(p => `${p.name}@${p.version}`).join(' ');

            const body = `## ðŸ“¦ Dev Release Published

            A dev release has been published for this PR!

            | Package | Version |
            | --- | --- |
            ${tableRows}

            **Install:**
            \`\`\`sh
            npm i ${packageVersions} --save-exact
            \`\`\`

            [View workflow run](${run_url})`;

            // Comment on each PR
            for (const pr of prs) {
              console.log(`Commenting on PR #${pr.number}`);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: body.split('\n').map(line => line.trim()).join('\n')
              });
            }
