import path from "node:path";
import type { Plugin } from "rolldown";
import { formatWithPrettier } from "../utils.ts";

/**
 * Configuration for an extra import map entry that should be included
 * in the generated import map alongside the standard entrypoints.
 */
interface ExtraImportMapEntry {
  /** The modules to import from the path. Use "*" for namespace imports. */
  modules: Array<string>;
  /** The alias parts that will be joined with "__" to create the export name. */
  alias: Array<string>;
  /** The import path to import from. */
  path: string;
}

/**
 * Configuration options for the import map plugin.
 */
export interface ImportMapPluginOptions {
  /** Whether the plugin is enabled. Defaults to true. */
  enabled?: boolean;
  /** The output path for the generated import map file. Defaults to "src/load/import_map.ts". */
  outputPath?: string;

  /** List of entrypoint keys that import optional dependencies and should be excluded. */
  importsOptionalDependencies?: string[];
  /** List of entrypoint keys that are node-only and should be excluded. */
  nodeOnly?: string[];
  /** List of entrypoint keys that should be omitted from the import map. */
  omitFromImportMap?: string[];

  /** Additional import map entries to include beyond the standard entrypoints. */
  extraEntries?: ExtraImportMapEntry[];

  /** The working directory to use for the plugin. Defaults to `process.env.INIT_CWD || ""`. */
  cwd?: string;
}

/**
 * Rolldown plugin that generates an import map file for dynamic imports.
 *
 * This plugin:
 * 1. Reads the build input entrypoints
 * 2. Filters out entrypoints based on configuration (node-only, optional deps, etc.)
 * 3. Generates re-export statements for each entrypoint
 * 4. Handles extra import map entries with custom import/export patterns
 * 5. Writes the generated import map to a TypeScript file
 *
 * The generated import map allows for dynamic imports using string keys,
 * which is useful for lazy loading and code splitting.
 *
 * @example
 * Basic usage:
 * ```ts
 * importMapPlugin({
 *   outputPath: "src/load/import_map.ts",
 *   nodeOnly: ["node-specific-module"],
 *   importsOptionalDependencies: ["optional-feature"]
 * })
 * ```
 *
 * @example
 * With extra entries:
 * ```ts
 * importMapPlugin({
 *   extraEntries: [
 *     {
 *       modules: ["*"],
 *       alias: ["utils", "helpers"],
 *       path: "./utils/helpers.js"
 *     }
 *   ]
 * })
 * ```
 *
 * @param param - Configuration options for the plugin
 * @returns A Rolldown plugin instance
 */
export function importMapPlugin(param: ImportMapPluginOptions = {}): Plugin {
  const options = {
    enabled: true,
    outputPath: "src/load/import_map.ts",
    importsOptionalDependencies: [],
    nodeOnly: [],
    omitFromImportMap: [],
    extraEntries: [],
    cwd: process.env.INIT_CWD ?? "",
    ...param,
  } as Required<ImportMapPluginOptions>;

  const outputPath = path.resolve(options.cwd, options.outputPath);

  return {
    name: "import-map",
    async buildStart({ input }) {
      if (!options.enabled) return;

      const entrypoints = Object.entries(input).filter(([key]) => {
        // Skip if it's the special "load" entrypoint
        if (key === "load") return false;

        // Skip if it's deprecated/node-only
        if (options.nodeOnly.includes(key)) return false;

        // Skip if it requires optional dependency
        if (options.importsOptionalDependencies.includes(key)) return false;

        // Skip if it's deprecated and should be omitted from import map
        if (options.omitFromImportMap.includes(key)) return false;

        return true;
      });

      const dedupedImportEntries = options.extraEntries.reduce(
        (acc, { modules, path }) => {
          acc[path] ??= { modules: [], alias: [], path };
          acc[path].modules.push(...modules);
          return acc;
        },
        {} as Record<string, ExtraImportMapEntry>
      );

      const lines = [
        `/** Auto-generated by import-map plugin. Do not edit manually */`,
        ``,
        // Generate import lines for each entrypoint
        ...entrypoints.map(([key, entrypointPath]) => {
          // Get relative path of the entrypoint from the package root
          const relativePath = path.relative(
            path.join(options.cwd, "src"),
            entrypointPath
          );

          // Transform slashes to double underscores for export names
          let normalizedKey = key;
          if (normalizedKey.endsWith("/index")) {
            normalizedKey = normalizedKey.substring(
              0,
              normalizedKey.length - "/index".length
            );
          }
          const exportName = normalizedKey.replace(/[/\\]/g, "__");

          // Transform the path to the compiled output
          // if path ends with .ts, replace with .js, otherwise append .js
          const cleanPath = relativePath
            .replace(/^\.\//, "")
            .replace(/^src\//, "");
          const outputPath = cleanPath.endsWith(".ts")
            ? cleanPath.replace(/\.ts$/, ".js")
            : `${cleanPath}.js`;

          return `export * as ${exportName} from "../${outputPath.replace(/\\/g, "/")}";`;
        }),
        // Generate namespace imports for extra entries
        ...options.extraEntries.reduce((acc, { modules, alias, path }) => {
          if (modules.includes("*")) {
            acc.push(`export * as ${alias.join("__")} from "${path}";`);
          }
          return acc;
        }, [] as string[]),
        // Generate regular imports statements for extra entries
        ...Object.values(dedupedImportEntries).reduce(
          (acc, { modules, path }) => {
            if (!modules.includes("*")) {
              acc.push(
                `import {\n  ${modules.join(",\n  ")}\n} from "${path}";`
              );
            }
            return acc;
          },
          [] as string[]
        ),
        // Generate alias declarations and exports for extra entries
        ...options.extraEntries.reduce((acc, { modules, alias }) => {
          const exportAlias = alias.join("__");
          acc.push(`const ${exportAlias} = {\n  ${modules.join(",\n  ")}\n};`);
          acc.push(`export { ${exportAlias} };`);
          return acc;
        }, [] as string[]),
      ];

      await this.fs.writeFile(
        outputPath,
        await formatWithPrettier(lines.join("\n"))
      );
      this.info(`üìù Generated import map file: ${outputPath}`);
    },
  };
}
