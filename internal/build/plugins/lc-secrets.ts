import fs from "node:fs";
import path from "node:path";
import ts from "typescript";
import type { Plugin, PluginContext } from "rolldown";
import { formatWithPrettier } from "../utils";

/**
 * Configuration options for the lc-secrets plugin.
 *
 * This plugin scans TypeScript files for `lc_secrets` patterns and generates
 * a TypeScript interface documenting all secrets used in the package.
 */
export interface SecretPluginOptions {
  /**
   * Whether to enable secret scanning.
   *
   * @default true
   */
  enabled?: boolean;

  /**
   * Whether to throw errors on validation failures.
   *
   * @default true
   */
  strict?: boolean;

  /**
   * Path for the generated secret map file, relative to the package root.
   *
   * @default "src/load/import_type.ts"
   */
  outputPath?: string;

  /**
   * File patterns to exclude from scanning.
   *
   * @default [".test.ts", "test.ts", ".spec.ts", "spec.ts"]
   */
  excludePatterns?: string[];
}

interface SecretInfo {
  name: string;
  fileName: string;
  line: number;
}

/**
 * Rolldown plugin for scanning lc_secrets patterns and generating TypeScript interfaces.
 *
 * ## What is the lc_secrets pattern?
 *
 * LangChain uses a standardized convention where classes that need access to sensitive
 * configuration (API keys, tokens, passwords) declare them via a special getter method
 * called `lc_secrets`. This getter returns a mapping between internal property names
 * and environment variable names:
 *
 * ```typescript
 * class OpenAIProvider {
 *   get lc_secrets(): { [key: string]: string } {
 *     return {
 *       apiKey: "OPENAI_API_KEY",        // Maps this.apiKey -> process.env.OPENAI_API_KEY
 *       organization: "OPENAI_ORG_ID",   // Maps this.organization -> process.env.OPENAI_ORG_ID
 *     };
 *   }
 * }
 * ```
 *
 * ## What this plugin does:
 *
 * 1. **Scans** all TypeScript files in your package for classes with `lc_secrets` getters
 * 2. **Extracts** the environment variable names (e.g., "OPENAI_API_KEY", "OPENAI_ORG_ID")
 * 3. **Validates** that they follow LangChain conventions (UPPERCASE, no spaces)
 * 4. **Generates** a TypeScript interface (`SecretMap`) that documents all secrets used
 * 5. **Reports** any validation errors and prevents builds with invalid secret names
 *
 * This ensures consistency across all LangChain packages, provides type safety for
 * environment variables, and helps developers understand what secrets each package requires.
 *
 * @param options - Configuration options for the plugin
 * @returns A Rolldown plugin instance
 *
 * @example
 * Basic usage:
 * ```ts
 * lcSecretsPlugin({
 *   outputPath: "src/load/import_type.ts"
 * })
 * ```
 */
export function lcSecretsPlugin(options: SecretPluginOptions = {}): Plugin {
  const opts = {
    enabled: true,
    strict: true,
    outputPath: "src/load/import_type.ts",
    excludePatterns: [".test.ts", "test.ts", ".spec.ts", "spec.ts"],
    ...options,
  };

  const packagePath = process.env.INIT_CWD ?? "";
  const outputPath = path.resolve(packagePath, opts.outputPath);

  return {
    name: "lc-secrets",
    async buildStart(this: PluginContext) {
      if (!options.enabled) return;

      try {
        const secrets = scanForSecrets(opts.excludePatterns);
        if (secrets.length > 0) {
          this.info(`ðŸ”‘ Found ${secrets.length} secrets in package`);

          // Validate secrets
          const errors = validateSecrets(secrets);
          if (errors.length > 0) {
            this.warn("âŒ Secret validation errors:");
            errors.forEach((error) => this.warn(`   - ${error}`));

            if (opts.strict) {
              throw new Error("Secret validation failed");
            }
          }

          const uniqueSecrets = [...new Set(secrets.map((s) => s.name))].sort();

          const lines = [
            `/** Auto-generated by lc-secrets plugin. Do not edit manually */`,
            ``,
            `export interface OptionalImportMap {}`,
            ``,
            `export interface SecretMap {`,
            ...uniqueSecrets.map((secret) => `  ${secret}?: string;`),
            `}`,
          ];

          await this.fs.writeFile(
            outputPath,
            await formatWithPrettier(lines.join("\n"))
          );
          this.info(`ðŸ“ Generated secret map: ${opts.outputPath}`);
        }
      } catch (error) {
        if (opts.strict) throw error;
      }
    },
  };
}

/**
 * Scan TypeScript files for lc_secrets patterns
 */
function scanForSecrets(excludePatterns: string[]): SecretInfo[] {
  const secrets: SecretInfo[] = [];
  const packagePath = process.env.INIT_CWD ?? "";

  // Find tsconfig.json
  const tsConfigPath = path.resolve(packagePath, "tsconfig.json");
  if (!fs.existsSync(tsConfigPath)) {
    return secrets;
  }

  const tsConfig = ts.parseJsonConfigFileContent(
    ts.readJsonConfigFile(tsConfigPath, (p: string) =>
      fs.readFileSync(p, "utf-8")
    ),
    ts.sys,
    path.resolve(packagePath, "src")
  );

  const tsConfigTarget = tsConfig.options.target || ts.ScriptTarget.ES2020;

  // Filter files to scan
  const filesToScan = tsConfig.fileNames.filter(
    (fileName: string) =>
      !excludePatterns.some((pattern) => fileName.includes(pattern))
  );

  for (const fileName of filesToScan) {
    if (!fs.existsSync(fileName)) {
      continue;
    }

    try {
      const sourceFile = ts.createSourceFile(
        fileName,
        fs.readFileSync(fileName, "utf-8"),
        tsConfigTarget,
        true
      );

      scanSourceFile(sourceFile, fileName, secrets);
    } catch (error) {
      // Silently skip files that can't be parsed
    }
  }

  return secrets;
}

/**
 * Scan a single source file for lc_secrets patterns
 */
function scanSourceFile(
  sourceFile: ts.SourceFile,
  fileName: string,
  secrets: SecretInfo[]
) {
  function visit(node: ts.Node) {
    if (ts.isClassDeclaration(node) || ts.isClassExpression(node)) {
      ts.forEachChild(node, (classNode: ts.Node) => {
        if (
          ts.isGetAccessor(classNode) &&
          classNode.name?.getText() === "lc_secrets"
        ) {
          classNode.body?.statements.forEach((stmt: ts.Statement) => {
            if (
              ts.isReturnStatement(stmt) &&
              stmt.expression &&
              ts.isObjectLiteralExpression(stmt.expression)
            ) {
              stmt.expression.properties.forEach(
                (element: ts.ObjectLiteralElementLike) => {
                  if (
                    ts.isPropertyAssignment(element) &&
                    element.initializer &&
                    ts.isStringLiteral(element.initializer)
                  ) {
                    const secretName = element.initializer.text;
                    const position = sourceFile.getLineAndCharacterOfPosition(
                      element.initializer.getStart()
                    );

                    secrets.push({
                      name: secretName,
                      fileName,
                      line: position.line + 1,
                    });
                  }
                }
              );
            }
          });
        }
      });
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
}

/**
 * Validate secret names according to LangChain conventions
 */
function validateSecrets(secrets: SecretInfo[]): string[] {
  const errors: string[] = [];

  for (const secret of secrets) {
    // Must be uppercase
    if (secret.name.toUpperCase() !== secret.name) {
      errors.push(
        `Secret identifier must be uppercase: ${secret.name} at ${secret.fileName}:${secret.line}`
      );
    }

    // No whitespace
    if (/\s/.test(secret.name)) {
      errors.push(
        `Secret identifier must not contain whitespace: ${secret.name} at ${secret.fileName}:${secret.line}`
      );
    }
  }

  return errors;
}
