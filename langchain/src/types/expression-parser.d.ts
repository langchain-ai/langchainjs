declare interface ParseOptions {
  filename?: string;
  startRule?: "Start";
  tracer?: any;
  [key: string]: any;
}
declare type ParseFunction = <Options extends ParseOptions>(
  input: string,
  options?: Options
) => Options extends { startRule: infer StartRule }
  ? StartRule extends "Start"
    ? Start
    : Start
  : Start;

// These types were autogenerated by ts-pegjs
declare type Start = Program;
declare type Identifier = IdentifierName;
declare type IdentifierName = { type: "Identifier"; name: string };
declare type Literal =
  | NullLiteral
  | BooleanLiteral
  | NumericLiteral
  | StringLiteral;
declare type NullLiteral = { type: "NullLiteral"; value: null };
declare type BooleanLiteral =
  | { type: "BooleanLiteral"; value: true }
  | { type: "BooleanLiteral"; value: false };
declare type NumericLiteral = DecimalLiteral;
declare type DecimalLiteral = { type: "NumericLiteral"; value: number };
declare type StringLiteral = { type: "StringLiteral"; value: string };
declare type PrimaryExpression =
  | Identifier
  | Literal
  | ArrayExpression
  | ObjectExpression
  | Expression;
declare type ArrayExpression = {
  type: "ArrayExpression";
  elements: ElementList;
};
declare type ElementList = PrimaryExpression[];
declare type ObjectExpression =
  | { type: "ObjectExpression"; properties: [] }
  | { type: "ObjectExpression"; properties: PropertyNameAndValueList };
declare type PropertyNameAndValueList = PrimaryExpression[];
declare type PropertyAssignment = {
  type: "PropertyAssignment";
  key: PropertyName;
  value: Expression;
  kind: "init";
};
declare type PropertyName = IdentifierName | StringLiteral | NumericLiteral;
declare type MemberExpression =
  | {
      type: "MemberExpression";
      property: StringLiteral;
      computed: true;
      object: MemberExpression | Identifier | StringLiteral;
    }
  | {
      type: "MemberExpression";
      property: Identifier;
      computed: false;
      object: MemberExpression | Identifier | StringLiteral;
    };
declare type CallExpression = {
  type: "CallExpression";
  arguments: Arguments;
  callee: MemberExpression | Identifier;
};
declare type Arguments = PrimaryExpression[];
declare type Expression = CallExpression | MemberExpression;
declare type ExpressionStatement = {
  type: "ExpressionStatement";
  expression: Expression;
};
declare type Program = { type: "Program"; body: ExpressionStatement };
declare type ExpressionNode =
  | Program
  | ExpressionStatement
  | ArrayExpression
  | BooleanLiteral
  | CallExpression
  | Identifier
  | MemberExpression
  | NumericLiteral
  | ObjectExpression
  | PropertyAssignment
  | NullLiteral
  | StringLiteral;
