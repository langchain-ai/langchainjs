export interface ParseOptions {
  filename?: string;
  startRule?: "Start";
  tracer?: any;
  [key: string]: any;
}
export type ParseFunction = <Options extends ParseOptions>(
  input: string,
  options?: Options
) => Options extends { startRule: infer StartRule }
  ? StartRule extends "Start"
    ? Start
    : Start
  : Start;

// These types were autogenerated by ts-pegjs
export type Start = Program;
export type Identifier = IdentifierName;
export type IdentifierName = { type: "Identifier"; name: string };
export type Literal =
  | NullLiteral
  | BooleanLiteral
  | NumericLiteral
  | StringLiteral;
export type NullLiteral = { type: "NullLiteral"; value: null };
export type BooleanLiteral =
  | { type: "BooleanLiteral"; value: true }
  | { type: "BooleanLiteral"; value: false };
export type NumericLiteral = DecimalLiteral;
export type DecimalLiteral = { type: "NumericLiteral"; value: number };
export type StringLiteral = { type: "StringLiteral"; value: string };
export type PrimaryExpression =
  | Identifier
  | Literal
  | ArrayExpression
  | ObjectExpression
  | Expression;
export type ArrayExpression = {
  type: "ArrayExpression";
  elements: ElementList;
};
export type ElementList = PrimaryExpression[];
export type ObjectExpression =
  | { type: "ObjectExpression"; properties: [] }
  | { type: "ObjectExpression"; properties: PropertyNameAndValueList };
export type PropertyNameAndValueList = PrimaryExpression[];
export type PropertyAssignment = {
  type: "PropertyAssignment";
  key: PropertyName;
  value: Expression;
  kind: "init";
};
export type PropertyName = IdentifierName | StringLiteral | NumericLiteral;
export type MemberExpression =
  | {
      type: "MemberExpression";
      property: StringLiteral;
      computed: true;
      object: MemberExpression | Identifier | StringLiteral;
    }
  | {
      type: "MemberExpression";
      property: Identifier;
      computed: false;
      object: MemberExpression | Identifier | StringLiteral;
    };
export type CallExpression = {
  type: "CallExpression";
  arguments: Arguments;
  callee: MemberExpression | Identifier;
};
export type Arguments = PrimaryExpression[];
export type Expression = CallExpression | MemberExpression;
export type ExpressionStatement = {
  type: "ExpressionStatement";
  expression: Expression;
};
export type Program = { type: "Program"; body: ExpressionStatement };
export type ExpressionNode =
  | Program
  | ExpressionStatement
  | ArrayExpression
  | BooleanLiteral
  | CallExpression
  | Identifier
  | MemberExpression
  | NumericLiteral
  | ObjectExpression
  | PropertyAssignment
  | NullLiteral
  | StringLiteral;
